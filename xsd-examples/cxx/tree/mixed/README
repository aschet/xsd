This example shows how to access the underlying DOM nodes in the
C++/Tree mapping in order to handle raw, "type-less content" such
as mixed content models, anyType/anySimpleType, and any/anyAttribute.

For an alternative (and recommended) approach that employs ordered
types see the order/mixed example.

For an alternative approach that employes type customization see
examples in the custom/ directory, in particular, custom/mixed and
custom/wildcard.

In this example we use mixed content model to describe text with
embedded links, e.g.,

  This paragraph talks about <a href="uri">time</a>.

The example transforms such text into plain text with references, e.g.,

  This paragraph talks about time[0].

  [0] uri

The example consists of the following files:

text.xsd
  XML Schema which describes "text with links" instance documents.

text.xml
  Sample XML instance document.

text.hxx
text.cxx
  C++ types that represent the given vocabulary and a set of parsing
  functions that convert XML instance documents to a tree-like in-memory
  object model.

  These files are generated by the XSD compiler from text.xsd using the
  following command line:

  xsd cxx-tree text.xsd

driver.cxx
  Driver for the example. It first calls one of the parsing functions
  that constructs the object model from the input file. It then uses
  both the underlying DOM and statically-typed mapping to perform the
  transformation.

To compile and link the example manually from the command line we can use
the following commands (replace 'c++' with your C++ compiler name):

c++ -DXSD_CXX11 -c text.cxx
c++ -DXSD_CXX11 -c driver.cxx
c++ -o driver driver.o text.o -lxerces-c

Note that we need to define the XSD_CXX11 preprocessor macro since the
source code includes libxsd headers directly.

To run the example on the sample XML instance document execute:

./driver text.xml
